from tuxemon.map import dirs3, dirs2, get_direction
from tuxemon.tools import trunc


class Movement:
    """

    Move game entities on a grid:
    * waypoints
    * pathfinding

    """

    def __init__(self, map, entity):
        self.map = map
        self.entity = entity

        self.pathfinding = None
        self.path = []
        self.final_move_dest = [0, 0]  # Stores the final destination sent from a client

        # pathfinding and waypoint related
        self.path_origin = None
        self._move_direction = None
        self.pathfinding = None
        self.path = []
        self.final_move_dest = [0, 0]  # Stores the final destination sent from a client

    def move_direction(self, direction):
        self._move_direction = direction

    def pathfind(self, destination):
        """ Find a path and also start it

        :param destination:
        :rtype: None
        """
        self.pathfinding = destination
        path = self.map.pathfind(tuple(self.tile_pos), destination)
        if path:
            self.path = path
            self.next_waypoint()

    def check_continue(self):
        try:
            pos = tuple(int(i) for i in self.tile_pos)
            direction_next = self.map.collision_map[pos]["continue"]
            self.move_one_tile(direction_next)
        except (KeyError, TypeError):
            pass

    def cancel_path(self):
        """ Stop following a path.

        NPC may still continue to move if move_direction has been set

        :return:
        """
        self.path = []
        self.pathfinding = None
        self.path_origin = None

    def cancel_movement(self):
        """ Gracefully stop moving.  If in a path, then will finish tile movement.

        Generally, use this if you want to stop.  Will stop at a tile coord.

        :return:
        """
        self._move_direction = None
        if self.tile_pos == self.path_origin:
            # we *just* started a new path; discard it and stop
            self.abort_movement()
        elif self.path and self.moving:
            # we are in the middle of moving between tiles
            self.path = [self.path[-1]]
            self.pathfinding = None
        else:
            # probably already stopped, just clear the path
            self.stop_moving()
            self.cancel_path()

    def abort_movement(self):
        """ Stop moving, cancel paths, and reset tile position to center

        The tile postion will be truncated, so even if there is another
        closer tile, it will always return the the tile where movement
        started.

        This is a useful method if you want to abort a path movement
        and also don't want to advance to another tile.

        :return:
        """
        if self.path_origin is not None:
            self.tile_pos = tuple(self.path_origin)
        self._move_direction = None
        self.stop_moving()
        self.cancel_path()

    def move(self, time_passed_seconds):
        """ Move the entity around the map

        * check if the move_direction variable is set
        * set the movement speed
        * follow waypoints
        * control walking animations
        * send network updates

        :param time_passed_seconds: A float of the time that has passed since the last frame.
            This is generated by clock.tick() / 1000.0.

        :type time_passed_seconds: Float
        """
        # update physics.  eventually move to another class
        self.update_physics(time_passed_seconds)

        if self.pathfinding and not self.path:
            # wants to pathfind, but there was no path last check
            self.pathfind(self.pathfinding)

        if self.path:
            if self.path_origin:
                # if path origin is set, then npc has started moving
                # from one tile to another.
                self.check_waypoint()
            else:
                # if path origin is not set, then a previous attempt to change
                # waypoints failed, so try again.
                self.next_waypoint()

        # does the npc want to move?
        if self._move_direction:
            if self.path and not self.moving:
                # npc wants to move and has a path, but it is blocked
                self.cancel_path()

            if not self.path:
                # there is no path, so start a new one
                self.move_one_tile(self._move_direction)
                self.next_waypoint()

        # TODO: determine way to tell if another force is moving the entity
        # TODO: basically, this simple check will only allow explicit npc movement
        # TODO: its not possible to move the entity with physics b/c this stops that
        if not self.path:
            self.cancel_movement()

        if self.moving:
            self.animation = "walk"
        else:
            self.animation = "idle"

    def move_one_tile(self, direction):
        """ Ask entity to move one tile

        :type direction: str
        :param direction: up, down, left right

        :return: None
        """
        self.path.append(trunc(self.tile_pos + dirs2[direction]))

    def valid_movement(self, tile):
        """ Check the game map to determine if a tile can be moved into

        * Only checks adjacent tiles
        * Uses all advanced tile movements, like continue tiles

        :param tile:
        :return:
        """
        return tile in self.map.get_exits(trunc(self.tile_pos)) or self.ignore_collisions

    @property
    def move_destination(self):
        """ Only used for the player_moved condition.

        :return:
        """
        if self.path:
            return self.path[-1]
        else:
            return None

    def next_waypoint(self):
        """ Take the next step of the path, stop if way is blocked

        * This must be called after a path is set
        * Not needed to be called if existing path is modified
        * If the next waypoint is blocked, the waypoint will be removed

        :return: None
        """
        target = self.path[-1]
        direction = get_direction(self.tile_pos, target)
        self.facing = direction
        if self.valid_movement(target):
            self.animation = "walking"
            self.path_origin = tuple(self.tile_pos)
            self.velocity3 = self.moverate * dirs3[direction]
        else:
            # the target is blocked now
            self.stop_moving()

            if self.pathfinding:
                # since we are pathfinding, just try a new path
                logger.error(f"{self.slug} finding new path!")
                self.pathfind(self.pathfinding)

            else:
                # give up and wait until the target is clear again
                pass

    def check_waypoint(self):
        """ Check if the waypoint is reached and sets new waypoint if so

        * For most accurate speed, tests distance traveled.
        * Doesn't verify the target position, just distance
        * Assumes once waypoint is set, direction doesn't change
        * Honors continue tiles

        :return: None
        """
        target = self.path[-1]
        expected = tile_distance(self.path_origin, target)
        traveled = tile_distance(self.tile_pos, self.path_origin)
        if traveled >= expected:
            self.set_position(target)
            self.path.pop()
            self.path_origin = None
            self.check_continue()  # handle "continue" tiles
            if self.path:
                self.next_waypoint()
